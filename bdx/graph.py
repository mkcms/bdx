from __future__ import annotations

from collections import deque
from enum import Enum
from pathlib import Path
from typing import Any, Callable, Iterator, Optional

from pygraphviz import AGraph

from bdx import debug, detail_log, trace
from bdx.binary import Symbol
from bdx.index import SymbolIndex, sigint_catcher


class GraphAlgorithm(Enum):
    """Enumeration for graph search algorithms."""

    BFS = "BFS"
    DFS = "DFS"


def _find_references(index: SymbolIndex, symbol: Symbol) -> set[Symbol]:
    cache = getattr(index, "__reference_cache", None)
    if cache is None:
        cache = dict()
        setattr(index, "__reference_cache", cache)

    try:
        return cache[symbol]
    except KeyError:
        query = index.schema["relocations"].make_query(symbol.name)
        res = set(index.search(query))
        cache[symbol] = res
        return res


def _bfs_or_dfs_search(
    index: SymbolIndex,
    start_set: set[Symbol],
    to_query_set: set[Symbol],
    algo: GraphAlgorithm,
    should_quit: Callable[[], bool],
    on_symbol_visited: Callable[[], Any],
) -> Iterator[list[Symbol]]:
    queue: deque[tuple[Symbol, list[Symbol]]] = deque(
        [(sym, []) for sym in to_query_set]
    )

    while queue and not should_quit():
        symbol, came_from = queue.popleft()

        detail_log(
            "Visit: {} From: {} (depth {})",
            symbol.name,
            came_from[0].name if came_from else None,
            len(came_from),
        )

        if symbol in came_from:
            continue

        on_symbol_visited()

        if symbol in start_set and came_from:
            yield [symbol, *came_from]
            continue

        referenced_by = [
            (sym, [symbol, *came_from])
            for sym in _find_references(index, symbol)
        ]

        if algo == GraphAlgorithm.DFS:
            queue.extendleft(referenced_by)
        else:
            queue.extend(referenced_by)


def generate_graph(
    index_path: Path,
    from_query: str,
    to_query: str,
    algo: GraphAlgorithm = GraphAlgorithm.BFS,
    num_routes: Optional[int] = 1,
    demangle_names: bool = True,
    on_symbol_visited: Callable[[], Any] = lambda: None,
    on_route_found: Callable[[], Any] = lambda: None,
) -> AGraph:
    """Generate a graph from results of one query to another.

    The graph is generated by walking through all nodes referencing
    ``to_query`` recursively until we get a node matching ``from_query``.

    Args:
        index_path: The index to generate a graph for.
        from_query: Symbols matching this query we will be trying to reach.
        to_query: We will start from symbols matching this query.
        algo: The algorithm to use.
        num_routes: Exit after finding that many routes
            (if None, generate them infinitely).
        demangle_names: If True, all nodes will have attribute "label"
            containing the demangled name.
        on_symbol_visited: Called for each symbol visited.
        on_route_found: Called after a single route is found.

    """
    index = SymbolIndex.open(index_path, readonly=True)
    with sigint_catcher() as interrupted, index:
        graph = AGraph(
            beautify=True,
            overlap=False,
            splines=True,
            rankdir="LR",
        )

        from_subgraph: AGraph = graph.add_subgraph(
            name="cluster_from_query",
            label=f'Matching start query "{from_query}"',
            style="filled",
        )
        to_subgraph: AGraph = graph.add_subgraph(
            name="cluster_to_query",
            label=f'Matching end query "{to_query}"',
            style="filled",
        )

        nodes = set()

        if num_routes is None:
            num_routes = 9999999999999

        to_query_set = set(index.search(to_query))
        from_query_set = set(index.search(from_query))

        debug(
            "Start set has length {}, end set has length {}",
            len(from_query_set),
            len(to_query_set),
        )

        if not to_query_set or not from_query_set:
            return graph

        def add_node(graph: AGraph, symbol: Symbol):
            graph.add_node(symbol.name)
            node = graph.get_node(symbol.name)
            attr = node.attr  # pyright: ignore
            if demangle_names:
                attr["label"] = symbol.demangle_name()
            attr["bdx.path"] = symbol.path
            attr["bdx.address"] = symbol.address
            attr["bdx.section"] = symbol.section
            attr["bdx.size"] = symbol.size

        if algo in [GraphAlgorithm.DFS, GraphAlgorithm.BFS]:
            routes = _bfs_or_dfs_search(
                index,
                from_query_set,
                to_query_set,
                algo,
                interrupted,
                on_symbol_visited,
            )
        else:
            msg = f"Unknown algorithm: {algo}"
            raise ValueError(msg)

        for i, route in enumerate(routes):
            on_route_found()

            trace(
                "Found route {} -> ... -> {} of length {}",
                route[0].name,
                route[-1].name,
                len(route),
            )

            nodes.update(route)

            for prev, next in zip(route, route[1:]):
                graph.add_edge(
                    prev.name,
                    next.name,
                    dir="forward",
                )

            if num_routes == i + 1:
                break

        for node in nodes:
            if node in to_query_set:
                add_node(to_subgraph, node)
            elif node in from_query_set:
                add_node(from_subgraph, node)
            else:
                add_node(graph, node)

    return graph

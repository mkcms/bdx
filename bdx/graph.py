from __future__ import annotations

from pathlib import Path
from typing import Any, Callable, Iterator, Optional

from pygraphviz import AGraph

from bdx import debug, detail_log, trace
from bdx.binary import Symbol
from bdx.index import SymbolIndex, sigint_catcher


def generate_graph(
    index_path: Path,
    from_query: str,
    to_query: str,
    depth_first_search: bool = False,
    num_routes: Optional[int] = 1,
    demangle_names: bool = True,
    on_symbol_visited: Callable[[], Any] = lambda: None,
    on_route_found: Callable[[], Any] = lambda: None,
) -> AGraph:
    """Generate a graph from results of one query to another.

    The graph is generated by walking through all nodes referencing
    ``to_query`` recursively until we get a node matching ``from_query``.

    Args:
        index_path: The index to generate a graph for.
        from_query: Symbols matching this query we will be trying to reach.
        to_query: We will start from symbols matching this query.
        depth_first_search: If True, use DFS algorithm, otherwise use
            breadth first search.
        num_routes: Exit after finding that many routes
            (if None, generate them infinitely).
        demangle_names: If True, all nodes will have attribute "label"
            containing the demangled name.
        on_symbol_visited: Called for each symbol visited.
        on_route_found: Called after a single route is found.

    """
    index = SymbolIndex.open(index_path, readonly=True)
    with sigint_catcher() as interrupted, index:
        graph = AGraph(
            beautify=True,
            overlap=False,
            splines=True,
            rankdir="LR",
        )

        from_subgraph: AGraph = graph.add_subgraph(
            name="cluster_from_query",
            label=f'Matching start query "{from_query}"',
            style="filled",
        )
        to_subgraph: AGraph = graph.add_subgraph(
            name="cluster_to_query",
            label=f'Matching end query "{to_query}"',
            style="filled",
        )

        nodes = set()

        if num_routes is None:
            num_routes = 9999999999999

        end_set = set(index.search(to_query))
        start_set = set(index.search(from_query))

        debug(
            "Start set has length {}, end set has length {}",
            len(start_set),
            len(end_set),
        )

        if not end_set or not start_set:
            return graph

        refs_cache: dict[Symbol, set[Symbol]] = dict()

        def find_references(symbol: Symbol) -> set[Symbol]:
            res = refs_cache.get(symbol, None)
            if res:
                return res

            query = index.schema["relocations"].make_query(symbol.name)
            res = set(index.search(query))
            refs_cache[symbol] = res
            return res

        def find_routes() -> Iterator[list[Symbol]]:
            queue: list[tuple[Symbol, list[Symbol]]] = [
                (sym, []) for sym in end_set
            ]

            while queue and not interrupted():
                symbol, came_from = queue.pop(0)

                detail_log(
                    "Visit: {} From: {} (depth {})",
                    symbol.name,
                    came_from[0].name if came_from else None,
                    len(came_from),
                )

                if symbol in came_from:
                    continue

                on_symbol_visited()

                if symbol in start_set and came_from:
                    yield [symbol, *came_from]
                    continue

                referenced_by = [
                    (sym, [symbol, *came_from])
                    for sym in find_references(symbol)
                ]

                if depth_first_search:
                    referenced_by.extend(queue)
                    queue = referenced_by
                else:
                    queue.extend(referenced_by)

        def add_node(graph: AGraph, symbol: Symbol):
            graph.add_node(symbol.name)
            node = graph.get_node(symbol.name)
            attr = node.attr  # pyright: ignore
            if demangle_names:
                attr["label"] = symbol.demangle_name()
            attr["bdx.path"] = symbol.path
            attr["bdx.address"] = symbol.address
            attr["bdx.section"] = symbol.section
            attr["bdx.size"] = symbol.size

        for i, route in enumerate(find_routes()):
            on_route_found()

            trace(
                "Found route {} -> ... -> {} of length {}",
                route[0].name,
                route[-1].name,
                len(route),
            )

            nodes.update(route)

            for prev, next in zip(route, route[1:]):
                graph.add_edge(
                    prev.name,
                    next.name,
                    dir="forward",
                )

            if num_routes == i + 1:
                break

        for node in nodes:
            if node in end_set:
                add_node(to_subgraph, node)
            elif node in start_set:
                add_node(from_subgraph, node)
            else:
                add_node(graph, node)

    return graph
